/**
 * POST /api/invites   — get the current invite token (or create one)
 * POST /api/invites   { rotate: true } — create a fresh token (invalidates old ones)
 * DELETE /api/invites { boardId } — revoke all tokens for a board
 *
 * All operations require the caller to be a member of the board.
 */
import type { VercelRequest, VercelResponse } from "@vercel/node";
import { verifyToken, AuthError } from "./_lib/auth.js";
import { getSupabaseAdmin } from "./_lib/supabaseAdmin.js";

export default async function handler(req: VercelRequest, res: VercelResponse) {
  res.setHeader("Access-Control-Allow-Origin", "*");
  res.setHeader("Access-Control-Allow-Methods", "GET, POST, DELETE, OPTIONS");
  res.setHeader("Access-Control-Allow-Headers", "Content-Type, Authorization");
  if (req.method === "OPTIONS") return res.status(200).end();

  // ── Public preview — no auth required ──────────────────────────────────────
  // GET /api/invites?token=xxx — returns board title + validity for the accept page
  if (req.method === "GET") {
    const { token } = req.query as { token?: string };
    if (!token) return res.status(400).json({ error: "token is required" });

    const supabase = getSupabaseAdmin();
    const { data: invite } = await supabase
      .from("board_invites")
      .select("expires_at, boards(title)")
      .eq("token", token)
      .maybeSingle();

    if (!invite) return res.status(404).json({ valid: false, reason: "not_found" });
    if (new Date(invite.expires_at) < new Date()) {
      return res.status(200).json({ valid: false, reason: "expired" });
    }
    return res.status(200).json({
      valid: true,
      boardTitle: (invite as any).boards?.title ?? "Untitled Board",
    });
  }

  try {
    const uid = await verifyToken(req.headers.authorization as string | null);
    const supabase = getSupabaseAdmin();

    if (req.method === "POST") {
      const { boardId, rotate = false } = (req.body ?? {}) as {
        boardId?: string;
        rotate?: boolean;
      };

      if (!boardId) return res.status(400).json({ error: "boardId is required" });

      // Verify caller is a member of this board
      const { data: membership } = await supabase
        .from("board_members")
        .select("role")
        .eq("board_id", boardId)
        .eq("user_id", uid)
        .maybeSingle();

      if (!membership) return res.status(403).json({ error: "Not a member of this board" });

      if (rotate) {
        // Delete all existing tokens so old links stop working
        await supabase.from("board_invites").delete().eq("board_id", boardId);
      } else {
        // Return existing non-expired token if one exists
        const { data: existing } = await supabase
          .from("board_invites")
          .select("token")
          .eq("board_id", boardId)
          .gt("expires_at", new Date().toISOString())
          .order("created_at", { ascending: false })
          .limit(1)
          .maybeSingle();

        if (existing) return res.status(200).json({ token: existing.token });
      }

      // Insert a new token (token value generated by DB default)
      const { data, error } = await supabase
        .from("board_invites")
        .insert({ board_id: boardId, created_by: uid })
        .select("token")
        .single();

      if (error) throw error;
      return res.status(200).json({ token: data.token });
    }

    if (req.method === "DELETE") {
      const { boardId } = (req.body ?? {}) as { boardId?: string };
      if (!boardId) return res.status(400).json({ error: "boardId is required" });

      // Verify caller is owner
      const { data: membership } = await supabase
        .from("board_members")
        .select("role")
        .eq("board_id", boardId)
        .eq("user_id", uid)
        .maybeSingle();

      if (!membership || membership.role !== "owner") {
        return res.status(403).json({ error: "Only owners can revoke invite links" });
      }

      await supabase.from("board_invites").delete().eq("board_id", boardId);
      return res.status(200).json({ ok: true });
    }

    return res.status(405).json({ error: "Method not allowed" });
  } catch (err: any) {
    if (err instanceof AuthError) return res.status(err.status).json({ error: err.message });
    console.error("[invites]", err);
    return res.status(500).json({ error: "Internal server error" });
  }
}
